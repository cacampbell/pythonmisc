#!/usr/bin/env python3
from os import environ
from shutil import which

from Bash import bash


def __get_backend():
    if which("scontrol"):
        return ("slurm")
    elif which("qstat"):
        return ("torque")


# Simple way to determine the backend for the cluster -- using API for commands
__BACKEND__ = environ["CLUSTER_BACKEND"] or __get_backend()


def __slurm_e_opts(str):
    options = ""

    for opt in str.split(",").upper().strip():
        if opt == "BEGIN" or opt == "START":
            options += "START,"
        if opt == "END" or opt == "FINISH":
            options += "END,"
        if opt == "FAIL" or opt == "ABORT":
            options += "FAIL,"

    return (options.rstrip(","))


def __submit_slurm(**kwargs):
    """
    Anticipated Keyword Arguments:
    command_str, memory, nodes, cpus, partition, job_name,
    depends_on, email_address, email_options, time, bash, input, output,
    error"""
    submit_cmd = ("sbatch")

    if "memory" in kwargs.keys():
        submit_cmd += (" --mem={}").format(kwargs["memory"])
    if "nodes" in kwargs.keys():
        submit_cmd += (" --ntasks={}").format(kwargs["nodes"])
    if "cpus" in kwargs.keys():
        submit_cmd += (" --cpus-per-task={}").format(kwargs["cpus"])
    if "partition" in kwargs.keys():
        submit_cmd += (" --partition={}").format(kwargs["partition"])
    if "job_name" in kwargs.keys():
        submit_cmd += (" --job-name={}").format(kwargs["job_name"])
    if "depends_on" in kwargs.keys():
        submit_cmd += (" --dependency=after_ok:{}").format(kwargs["depends_on"])
    if "email_address" in kwargs.keys():
        submit_cmd += (" --mail-user={}").format(kwargs["email_address"])
    if "email_options" in kwargs.keys():
        submit_cmd += (" --mail-options={}").format(
            __slurm_e_opts(kwargs["email_options"]))
    if "input" in kwargs.keys():
        submit_cmd += (" --input={}").format(kwargs["input"])
    if "output" in kwargs.keys():
        submit_cmd += (" --output={}").format(kwargs["output"])
    if "error" in kwargs.keys():
        submit_cmd += (" --error={}").format(kwargs["error"])


def __torque_e_opts(str):
    options = ""

    for opt in str.split(",").upper().strip():
        if opt == "BEGIN" or opt == "START":
            options += "b"
        if opt == "END":
            options += "e"
        if opt == "FAIL" or opt == "ABORT":
            options += "a"

    return (options)


def __submit_torque(**kwargs):
    """
        Anticipated Keyword Arguments:
        command_str, memory, nodes, cpus, partition, job_name,
        depends_on, email_address, email_options, time, bash, input, output,
        error"""

    # Memory uses -l mem=<MEM>
    # Tasks/Nodes and CPUs per node: " -l nodes=<Nodes>:ppn=<CPUs>"
    # In total, for mem, nodes, CPUs:
    # -l mem=<MEM>,nodes=<Nodes>:ppn=<CPUs_per_node>

    submit_cmd = ("qsub")
    if "partition" in kwargs.keys():
        submit_cmd += " -q {}".format(kwargs["partition"])
    if "job_name" in kwargs.keys():
        submit_cmd += " -N {}".format(kwargs["job_name"])
    if "depends_on" in kwargs.keys():
        submit_cmd += " -hold_jid {}".format(kwargs["depends_on"])
    if "email_address" in kwargs.keys():
        submit_cmd += " -M {}".format(kwargs["email_address"])
    if "email_options" in kwargs.keys():
        submit_cmd += "-m {}".format(__torque_e_opts(kwargs["email_options"]))
    if "input" in kwargs.keys():
        submit_cmd += " -i {}".format(kwargs["input"])
    if "output" in kwargs.keys():
        submit_cmd += " -o {}".format(kwargs["output"])
    if "error" in kwargs.keys():
        submit_cmd += " -e {}".format(kwargs["error"])

    return (submit_cmd)


def submit_job(command_str, **kwargs):
    shebang_line = kwargs["bash"] or "#!/usr/bin/env bash"
    script = ("{shebang_line}\n{{command}}").format(shebang_line=shebang_line)
    command = ("{command_str} | {{submit_cmd}}").format(command_str=command_str)

    if __BACKEND__ == "slurm":  # Format with slurm options
        command.format(submit_cmd=__submit_slurm(kwargs))
    elif __BACKEND__ == "torque":  # Format with torque options
        command.format(submit_cmd=__submit_torque(kwargs))

    script.format(command=command)  # <Shebang>\n<Command> | <Submission>
    (stdout, stderr) = bash(script)  # Actaully call the script using bash

    try:  # To parse the output based on expected successful submission result
        if __BACKEND__ == "slurm":
            # Successfully submitted job <Job ID>.
            return (stdout.split()[-1].rstrip("."))
        if __BACKEND__ == "torque":
            # <Job ID>.hostname.etc.etc
            return (stdout.split(".")[0])

    except (ValueError, IndexError) as err:
        print("Could not capture Job ID! Dependency checks may fail!")
        return ("")

def __cancel_jobs_slurm(*args):
    pass


def __cancel_jobs_torque(*args):
    pass


def cancel_jobs(*args):
    if __BACKEND__ == "slurm":
        __cancel_jobs_slurm(*args)
    elif __BACKEND__ == "torque":
        __cancel_jobs_torque(*args)


def __cancel_suspended_jobs_slurm():
    pass


def __cancel_suspended_jobs_torque():
    pass


def cancel_suspended_jobs():
    if __BACKEND__ == "slurm":
        __cancel_suspended_jobs_slurm()
    elif __BACKEND__ == "torque":
        __cancel_suspended_jobs_torque()


def __requeue_suspended_jobs_slurm():
    pass


def __requeue_suspended_jobs_torque():
    pass


def requeue_suspended_jobs():
    if __BACKEND__ == "slurm":
        __requeue_suspended_jobs_slurm()
    elif __BACKEND__ == "torque":
        __requeue_suspended_jobs_torque()


def __queued_jobs_slurm():
    pass


def __queued_jobs_torque():
    pass


def queued_jobs():
    if __BACKEND__ == "slurm":
        return __queued_jobs_slurm()
    elif __BACKEND__ == "torque":
        return __queued_jobs_torque()
